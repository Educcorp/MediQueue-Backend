/**
 * Middleware para control de rate limiting (cooldown) en creaci√≥n de turnos
 * Previene spam de creaci√≥n de turnos por dispositivo (Device ID + IP)
 */

// Almac√©n en memoria para tracking de dispositivos y timestamps
// En producci√≥n se recomienda usar Redis para persistencia y escalabilidad
const deviceCooldowns = new Map();

// Configuraci√≥n del cooldown (en milisegundos)
const COOLDOWN_DURATION = 60 * 1000; // 60 segundos de cooldown

/**
 * Limpieza peri√≥dica de dispositivos antiguos del Map
 * Ejecuta cada 5 minutos para evitar crecimiento infinito de memoria
 */
const cleanupInterval = setInterval(() => {
  const now = Date.now();
  let cleanedCount = 0;
  
  for (const [deviceKey, data] of deviceCooldowns.entries()) {
    // Eliminar entradas m√°s antiguas que el doble del cooldown
    if (now - data.timestamp > COOLDOWN_DURATION * 2) {
      deviceCooldowns.delete(deviceKey);
      cleanedCount++;
    }
  }
  
  if (cleanedCount > 0) {
    console.log(`üßπ [RATE-LIMITER] Limpiados ${cleanedCount} dispositivos antiguos del cooldown`);
  }
}, 5 * 60 * 1000); // Cada 5 minutos

/**
 * Obtiene la IP real del cliente
 * Considera proxies y load balancers
 */
const getClientIp = (req) => {
  // Intentar obtener IP de headers comunes de proxies
  const forwardedFor = req.headers['x-forwarded-for'];
  if (forwardedFor) {
    // x-forwarded-for puede contener m√∫ltiples IPs, tomar la primera
    return forwardedFor.split(',')[0].trim();
  }
  
  // Otros headers comunes
  const realIp = req.headers['x-real-ip'];
  if (realIp) {
    return realIp.trim();
  }
  
  // Cloudflare
  const cfConnectingIp = req.headers['cf-connecting-ip'];
  if (cfConnectingIp) {
    return cfConnectingIp.trim();
  }
  
  // IP directa del socket
  return req.connection?.remoteAddress || 
         req.socket?.remoteAddress || 
         req.ip || 
         'unknown';
};

/**
 * Obtiene el Device ID del cliente desde los headers
 */
const getDeviceId = (req) => {
  return req.headers['x-device-id'] || null;
};

/**
 * Genera una clave √∫nica combinando Device ID e IP
 * Si no hay Device ID, usa solo la IP (fallback)
 */
const getDeviceKey = (req) => {
  const deviceId = getDeviceId(req);
  const clientIp = getClientIp(req);
  
  // Si tenemos Device ID, usarlo como clave principal
  if (deviceId && deviceId !== 'undefined' && deviceId !== 'null') {
    return `device:${deviceId}`;
  }
  
  // Fallback: usar solo IP
  return `ip:${clientIp}`;
};

/**
 * Formatea el tiempo restante en segundos de manera legible
 */
const formatTimeRemaining = (milliseconds) => {
  const seconds = Math.ceil(milliseconds / 1000);
  if (seconds >= 60) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return remainingSeconds > 0 
      ? `${minutes} minuto${minutes > 1 ? 's' : ''} y ${remainingSeconds} segundo${remainingSeconds > 1 ? 's' : ''}`
      : `${minutes} minuto${minutes > 1 ? 's' : ''}`;
  }
  return `${seconds} segundo${seconds > 1 ? 's' : ''}`;
};

/**
 * Middleware de rate limiting para creaci√≥n de turnos
 * Aplica cooldown compartido entre todas las √°reas basado en Device ID
 */
const turnoCooldownMiddleware = (req, res, next) => {
  const deviceKey = getDeviceKey(req);
  const clientIp = getClientIp(req);
  const deviceId = getDeviceId(req);
  const now = Date.now();
  
  console.log(`üîç [RATE-LIMITER] Verificando cooldown para dispositivo: ${deviceKey.substring(0, 30)}... (IP: ${clientIp})`);
  
  // Verificar si el dispositivo est√° en cooldown
  const cooldownData = deviceCooldowns.get(deviceKey);
  
  if (cooldownData) {
    const timeElapsed = now - cooldownData.timestamp;
    const timeRemaining = COOLDOWN_DURATION - timeElapsed;
    
    // Si todav√≠a est√° en cooldown
    if (timeElapsed < COOLDOWN_DURATION) {
      const timeRemainingFormatted = formatTimeRemaining(timeRemaining);
      const timeElapsedSeconds = Math.floor(timeElapsed / 1000);
      
      console.log(`‚è≥ [RATE-LIMITER] Dispositivo ${deviceKey.substring(0, 30)}... en cooldown. Tiempo transcurrido: ${timeElapsedSeconds}s, Tiempo restante: ${Math.ceil(timeRemaining / 1000)}s`);
      
      return res.status(429).json({
        success: false,
        message: `Por favor espera ${timeRemainingFormatted} antes de solicitar otro turno`,
        error: 'COOLDOWN_ACTIVE',
        data: {
          timeRemaining: Math.ceil(timeRemaining / 1000), // en segundos
          lastTurnCreated: new Date(cooldownData.timestamp).toISOString(),
          cooldownDuration: COOLDOWN_DURATION / 1000 // en segundos
        }
      });
    }
    
    // El cooldown ha expirado, eliminar del Map
    console.log(`‚úÖ [RATE-LIMITER] Cooldown expirado para dispositivo ${deviceKey.substring(0, 30)}...`);
    deviceCooldowns.delete(deviceKey);
  }
  
  // Registrar la creaci√≥n del turno con timestamp actual
  deviceCooldowns.set(deviceKey, {
    timestamp: now,
    deviceId: deviceId,
    ip: clientIp
  });
  
  console.log(`‚úÖ [RATE-LIMITER] Dispositivo ${deviceKey.substring(0, 30)}... autorizado. Cooldown activado por ${COOLDOWN_DURATION / 1000}s`);
  console.log(`üìä [RATE-LIMITER] Dispositivos actualmente en cooldown: ${deviceCooldowns.size}`);
  
  next();
};

/**
 * Obtiene informaci√≥n sobre el estado del rate limiter (para debugging/admin)
 */
const getRateLimiterStats = () => {
  const now = Date.now();
  const activeDevices = [];
  
  for (const [deviceKey, data] of deviceCooldowns.entries()) {
    const timeElapsed = now - data.timestamp;
    const timeRemaining = COOLDOWN_DURATION - timeElapsed;
    
    if (timeRemaining > 0) {
      // Ocultar informaci√≥n sensible
      const maskedIp = data.ip ? data.ip.replace(/(\d+\.\d+\.\d+)\.\d+/, '$1.xxx') : 'unknown';
      const maskedDeviceId = data.deviceId ? data.deviceId.substring(0, 10) + '...' : 'no-device-id';
      
      activeDevices.push({
        deviceKey: deviceKey.substring(0, 20) + '...',
        deviceId: maskedDeviceId,
        ip: maskedIp,
        timeRemaining: Math.ceil(timeRemaining / 1000),
        lastCreated: new Date(data.timestamp).toISOString()
      });
    }
  }
  
  return {
    cooldownDuration: COOLDOWN_DURATION / 1000,
    activeDevicesCount: activeDevices.length,
    totalTrackedDevices: deviceCooldowns.size,
    activeDevices: activeDevices.sort((a, b) => a.timeRemaining - b.timeRemaining)
  };
};

/**
 * Limpia el cooldown de un dispositivo espec√≠fico (√∫til para testing o admin override)
 * Puede buscar por Device ID o por IP
 */
const clearDeviceCooldown = (identifier) => {
  // Intentar eliminar con diferentes formatos
  const deviceKey = `device:${identifier}`;
  const ipKey = `ip:${identifier}`;
  
  let deleted = deviceCooldowns.delete(deviceKey) || deviceCooldowns.delete(ipKey);
  
  // Si no se encuentra directamente, buscar por coincidencia parcial
  if (!deleted) {
    for (const [key, data] of deviceCooldowns.entries()) {
      if (key.includes(identifier) || data.deviceId === identifier || data.ip === identifier) {
        deviceCooldowns.delete(key);
        deleted = true;
        break;
      }
    }
  }
  
  console.log(`üîì [RATE-LIMITER] Cooldown ${deleted ? 'eliminado' : 'no encontrado'} para identificador: ${identifier}`);
  return deleted;
};

/**
 * Limpia todos los cooldowns (√∫til para testing)
 */
const clearAllCooldowns = () => {
  const count = deviceCooldowns.size;
  deviceCooldowns.clear();
  console.log(`üóëÔ∏è [RATE-LIMITER] Limpiados ${count} cooldowns de dispositivos`);
  return count;
};

// Alias para compatibilidad con c√≥digo existente
const clearIpCooldown = clearDeviceCooldown;

module.exports = {
  turnoCooldownMiddleware,
  getRateLimiterStats,
  clearDeviceCooldown,
  clearIpCooldown, // Alias para compatibilidad
  clearAllCooldowns,
  COOLDOWN_DURATION
};

